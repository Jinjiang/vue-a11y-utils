# vue-a11y-utils

[![LICENSE](https://img.shields.io/github/license/Jinjiang/vue-a11y-utils.svg?style=for-the-badge)](https://github.com/Jinjiang/vue-a11y-utils/blob/master/LICENSE)
[![CircleCI](https://img.shields.io/circleci/project/github/Jinjiang/vue-a11y-utils/master.svg?style=for-the-badge)](https://circleci.com/gh/Jinjiang/vue-a11y-utils/tree/master)

Utilities for accessibility (a11y) in Vue.js

## Summary

* [Why](#why)
* [`<VueAria>` Component](#vuearia-component)
* [`v-aria` Custome Directive](#v-aria-custom-directive)
* [`KeyTravel` Mixin](#keytravel-mixin)
* to be continued ...

## Why

When you write a Vue app with full accessible control. You may meet some issues frequently. For example:

- Make sure the [W3C ARIA](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA) roles & properties of each DOM element are set properly.
- Control the _focus_ and finish every task elegantly just by a _keyboard_.
- Using a central [live region](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Live_Regions) to show messages which are generated by the app, not the user.
- Sometimes you need set a _ID reference_ or _ID reference list_ type aria attribute with _ID_ of another DOM element. But we don't use _ID_ for such a long time right?

Vue A11y Utils try to supply a group of utilities to help Vue developers finish these jobs easier. They are:

## `<VueAria>` Component

This component helps you to write `role` and `aria-*` attributes better.

First you could put all `aria-*` attributes in an object. Second these a11y attributes could be inherited when more than 1 `<VueAria>` components nested. Third, it's more portable to use.

### API

#### props

* `role`: `string`
* `aria`: `Array` or `Object`
* `tabindex`: `number`

::: tip
When you pass `"none"` or `"appearance"` value into `role` prop but without a `tabindex` prop. The `tabindex` attribute on the root element will finally be `""`.
:::

#### slots

* default slot: the element you would put these a11y attributes on.

### Examples


#### For Props `role` And `aria`

``` vue
<template>
  <VueAria role="menubutton" :aria="aria">
    <button>WAI-ARIA Quick Links</button>
  </VueAria>
</template>

<script>
export default {
  components: { VueAria },
  data() {
    return {
      haspopup: true,
      controls: 'menu2'
    }
  }
}
</script>
```

which is same to:

``` vue
<template>
  <button id="menubutton" aria-haspopup="true" aria-controls="menu2">
    WAI-ARIA Quick Links
  </button>
</template>
```

So the content and structure is more clear than which with a lot of `aria-*` attribute in.

The `aria` prop could be an Array which is convenient to merge multiple `aria-*` attribute from different places:

``` vue
<template>
  <VueAria
    role="menubutton"
    :aria="[
      ariaData,
      ariaProps,
      otherAriaFromSomewhereElse
    ]"
  >
      <button>WAI-ARIA Quick Links</button>
  </VueAria>
</template>
```

And this component could be nested like:

``` vue
<template>
  <VueAria :aria="otherAriaFromSomewhereElse">
    <VueAria :aria="ariaProps">
      <VueAria role="menubutton" :aria="ariaData">
        <button>WAI-ARIA Quick Links</button>
      </VueAria>
    </VueAria>
  </VueAria>
</template>
```

or:

``` vue
<template>
  <VueAria role="menubutton">
    <VueAria :aria="aria">
      <button>WAI-ARIA Quick Links</button>
    </VueAria>
  </VueAria>
</template>
```

#### For Prop `tabindex`

If you want to make a ARIA widget focusable which is just a `<div>`. You should give it a `tabindex` attribute. For example:

``` vue
<template>
  <VueAria
    role="menubutton"
    :tabindex="0"
  >
    <div>WAI-ARIA Quick Links</div>
  </VueAria>
</template>
```

When you pass `"none"` or `"appearance"` value into `role` prop but without a `tabindex` prop. The `tabindex` attribute on the root element will finally be `""`. For examples:

``` vue
<template>
  <!-- won't be focused by click or TAB key -->
  <VueAria role="none">
    <div tabindex="0" role="menubutton">WAI-ARIA Quick Links</div>
  </VueAria>
</template>
```

``` vue
<template>
  <!-- won't be focused TAB key but could be focused by click -->
  <VueAria role="none" :tabindex="-1">
    <div role="button" tabindex="0">WAI-ARIA Quick Links</div>
  </VueAria>
</template>
```

## `v-aria` Custom Directive

If you prefer using directives rather than components, here is another choise: `v-aria` custom directive.

It helps you to write `aria-*` attributes better throught a Vue custom directive.

Almost the same to the `aria` prop in `<VueAria>` component, let you put all `aria-*` attributes in an object or array.

::: tip
Because the custom directive would modify the DOM element. It is different from component which renders virtual DOM. So `v-aria` will run after all `<VueAria>` executed if you put both of them on a same DOM element. And the performance of `v-aria` would be a little bit slow than `<VueAria>` if you use them quite a lot.
:::

### Examples

``` vue
<template>
  <i class="icon-save" role="button" v-aria="aria" />
</template>

<script>
export default {
  data() {
    return {
      aria: {
        label: 'save your changes',
        controls: 'id-of-a-textbox'
      }
    };
  },
  directives: {
    aria: directiveAria
  }
};
</script>
```

This example above is same to:

``` vue
<template>
  <i
    class="icon-save"
    role="button"
    aria-label="save your changes"
    aria-controls="id-of-a-textbox"
  >
</template>
```

Btw. there is not custom directives such as `v-role` and `v-tabindex` because you could set the two raw attributes directly on a component or an element with `v-aria`.

## `KeyTravel` Mixin

This mixin help you travel through focusable items by _arrow_ keys in a Vue component. At the same time you could easily fire an action by _enter_ key or _space_ key.

### Examples

#### Auto-focus

The first example is about auto-focus. Make sure where is a value (through a prop/data/computed etc.) named `autofocus` in the component. When it's truthy, the item returned by `getAutofocusItem()` would be focused when component mounted to the DOM.

``` vue
<template>
  <div>
    <button ref="btn">Click!</button>
  </div>
</template>

<script>
export default {
  mixins: [MixinKeyTravel],
  data() {
    return {
      // You can also define this value through `prop` or `computed` etc.
      autofocus: true
    }
  },
  methods: {
    // The mixin will call this method to find the focus when mounted to the DOM.
    getAutofocusItem() {
      return this.$refs.btn;
    }
  }
};
</script>
```

#### Focus Travel Using Arrow Keys

The second example is about focus travel using arrow keys in a Vue component. There are 2 files:

- `App.vue`:

  ``` vue
  <template>
    <div role="list" @keydown="keyTravel">
      <ListItem
        ref="items"
        v-for="option in options"
        :key="option.value"
        :text="option.text"
        :value="option.value"
      />
    </div>
  </template>

  <script>
  export default {
    mixins: [MixinKeyTravel],
    components: { ListItem },
    data() {
      return {
        autofocus: true,
        // Only ArrowUp and ArrowDown keys would work.
        orientation: 'vertical'
      };
    },
    props: {
      options: Array
    },
    methods: {
      // You need to define all focusable items here. And if you don't define
      // getAutofocusItem(), the first one you defined will be auto-focused.
      getKeyItems() {
        return this.$refs.items;
      }
    }
  };
  </script>
  ```

- `ListItem.vue`:

  ``` vue
  <template>
    <div role="listitem" tabindex="-1" @click="fireAction">{{ text }}</div>
  </template>

  <script>
  export default {
    props: {
      text: String,
      value: String
    },
    methods: {
      fireAction() {
        alert(this.value);
      }
    }
  };
  </script>
  ```

Here are some points you would notice:

1. Bind `@keydown="keyTravel"` to the root DOM element of your component.
2. Put a prop/data/computed named `orientation` to define which arrow keys would work.
3. Define a `getKeyItems()` method to return all focusable items.
4. Define a `fireAction()` method in `<ListItem>` for the action when user press enter or space.

Now you can use ArrowUp and ArrowDown keys to travel each items. When you press enter or space key, an alert with the value of the current focused item would be poped up.

### API

#### Method you can call

* `keyTravel(event: KeyboardEvent, config?: KeyConfig): void`

  The second parameter is optional. The key is the `key` in the keyboard event, and the value if the "travel signal" to trigger when user press the corresponding key.

  All available travel signals: `prev`, `next`, `prevPage`, `nextPage`, `first`, `last`, `action`.

  Default config:

  * `ArrowUp`: `prev` when `this.orientation` is `vertical` or empty
  * `ArrowDown`: `next` when `this.orientation` is `vertical` or empty
  * `ArrowLeft`: `prev` when `this.orientation` is `horizontal` or empty
  * `ArrowRight`: `next` when `this.orientation` is `horizontal` or empty
  * `Home`: `first`
  * `End`: `last`
  * `Enter`: `action`
  * `Space`: `action`


#### Values you can define

* `autofocus: boolean`
* `orientation: 'horizontal' | 'vertical' | other`

#### Methods you can override

_Main method for travel:_

* `getKeyItems(): Array<Vue | HTMLElement>`: return an empty array by default

_Main method for auto-focus:_

* `getAutofocusItem(): void`: return first key item by default

_Methods you can customize to fire action:_

* `fireAction(item: Vue | HTMLElement): void`: call `item.fireAction()` by default

_Methods you can customize to travel:_

* `goPrev(): void`: focus previous item
* `goNext(): void`: focus next item
* `goFirst(): void`: focus the first item
* `goLast(): void`: focus the last item
* `goNextPage(): void`: do nothing by default
* `goPrevPage(): void`: do nothing by default
* `goAction(): void`: fire action at the current focused item

#### Method you can define in item component

* `fireAction(): void`
