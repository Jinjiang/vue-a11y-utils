# vue-a11y-utils

<div style="display: flex; align-items: center;">
  <img src="https://vuejs.org/images/logo.png" width="200" height="200" />
  <svg width="200" height="200" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" version="1.1" x="0" y="0" viewBox="-3627 353 1024 1024" style="enable-background:new -3627 353 1024 1024;"><circle cx="-3115" cy="865" r="512" fill="#4dba87"></circle><path d="M-3116.4 353c-282 0-510.6 228.6-510.6 510.6s228.6 510.6 510.6 510.6s510.6-228.6 510.6-510.6S-2834.4 353-3116.4 353z M-3124.1 454.4c36.6 0 66.2 29.6 66.2 65.9c0 36.6-29.6 66.2-66.2 66.2c-36.3 0-65.9-29.6-65.9-66.2 C-3190.1 484-3160.5 454.4-3124.1 454.4L-3124.1 454.4z M-2838 667.7l-196.4 24.8l0.1 196.6l95.2 317.7c5 20.1-7 40.1-26.9 45.1 c-19.8 5-40.1-6-45.1-26l-97.5-289.2h-30l-89.7 295.2c-7.5 19.3-29 28.1-48.2 20.6c-19.1-7.4-30.7-29.1-23.2-48.4l82.4-311.8V692.5 l-181-24.6c-18.6-1.5-31.2-17.8-29.7-36.4c1.4-18.7 18.3-32.6 36.8-31.1l219.9 18.9h96.4l234.1-19.3c18.6-0.7 34.4 13.7 35 32.5 C-2805 651-2819.4 666.9-2838 667.7L-2838 667.7z" fill="#435466"></path></svg>
</div>

[![LICENSE](https://img.shields.io/github/license/Jinjiang/vue-a11y-utils.svg?style=for-the-badge)](https://github.com/Jinjiang/vue-a11y-utils/blob/master/LICENSE)
[![CircleCI](https://img.shields.io/circleci/project/github/Jinjiang/vue-a11y-utils/master.svg?style=for-the-badge)](https://circleci.com/gh/Jinjiang/vue-a11y-utils/tree/master)

Utilities for accessibility (a11y) in Vue.js

## Summary

* [Why](#why)
* [`<VueAria>` Component](#vuearia-component)
* [`v-aria` Custome Directive](#v-aria-custom-directive)
* [`KeyTravel` Mixin](#keytravel-mixin)
* [`Id` Mixin](#id-mixin)
* [`<VueFocusTrap>` Component](#vuefocustrap-component)
* [`KeyShortcuts` Mixin](@keyshortcuts-mixin)
* to be continued ...

## Why

When you write a Vue app with full accessible control. You may meet some issues frequently. For example:

- Make sure the [W3C WAI-ARIA](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA) roles & properties of each DOM element are set properly.
- Control the _focus_ and finish every task elegantly just by a _keyboard_.
- Using a central [live region](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Live_Regions) to show messages which are generated by the app, not the user.
- Sometimes you need set a _ID reference_ or _ID reference list_ type aria attribute with _ID_ of another DOM element. But we don't use _ID_ for such a long time right?

Vue A11y Utils try to supply a group of utilities to help Vue developers finish these jobs easier. They are:

## `<VueAria>` Component

This component helps you to write `role` and `aria-*` attributes better.

First you could put all `aria-*` attributes in an object. Second these a11y attributes could be inherited when more than 1 `<VueAria>` components nested. Third, it's more portable to use.

### API

#### props

* `role`: `string`
* `aria`: `Array` or `Object`
* `tabindex`: `number`

::: tip
When you pass `"none"` or `"appearance"` value into `role` prop but without a `tabindex` prop. The `tabindex` attribute on the root element will finally be `""`.
:::

#### slots

* default slot: the element you would put these a11y attributes on.

### Examples


#### For Props `role` And `aria`

``` vue
<template>
  <VueAria role="menubutton" :aria="aria">
    <button>WAI-ARIA Quick Links</button>
  </VueAria>
</template>

<script>
export default {
  components: { VueAria },
  data() {
    return {
      haspopup: true,
      controls: 'menu2'
    }
  }
}
</script>
```

which is same to:

``` vue
<template>
  <button id="menubutton" aria-haspopup="true" aria-controls="menu2">
    WAI-ARIA Quick Links
  </button>
</template>
```

So the content and structure is more clear than which with a lot of `aria-*` attribute in.

The `aria` prop could be an Array which is convenient to merge multiple `aria-*` attribute from different places:

``` vue
<template>
  <VueAria
    role="menubutton"
    :aria="[
      ariaData,
      ariaProps,
      otherAriaFromSomewhereElse
    ]"
  >
      <button>WAI-ARIA Quick Links</button>
  </VueAria>
</template>
```

And this component could be nested like:

``` vue
<template>
  <VueAria :aria="otherAriaFromSomewhereElse">
    <VueAria :aria="ariaProps">
      <VueAria role="menubutton" :aria="ariaData">
        <button>WAI-ARIA Quick Links</button>
      </VueAria>
    </VueAria>
  </VueAria>
</template>
```

or:

``` vue
<template>
  <VueAria role="menubutton">
    <VueAria :aria="aria">
      <button>WAI-ARIA Quick Links</button>
    </VueAria>
  </VueAria>
</template>
```

#### For Prop `tabindex`

If you want to make a ARIA widget focusable which is just a `<div>`. You should give it a `tabindex` attribute. For example:

``` vue
<template>
  <VueAria
    role="menubutton"
    :tabindex="0"
  >
    <div>WAI-ARIA Quick Links</div>
  </VueAria>
</template>
```

When you pass `"none"` or `"appearance"` value into `role` prop but without a `tabindex` prop. The `tabindex` attribute on the root element will finally be `""`. For examples:

``` vue
<template>
  <!-- won't be focused by click or TAB key -->
  <VueAria role="none">
    <div tabindex="0" role="menubutton">WAI-ARIA Quick Links</div>
  </VueAria>
</template>
```

``` vue
<template>
  <!-- won't be focused TAB key but could be focused by click -->
  <VueAria role="none" :tabindex="-1">
    <div role="button" tabindex="0">WAI-ARIA Quick Links</div>
  </VueAria>
</template>
```

## `v-aria` Custom Directive

If you prefer using directives rather than components, here is another choise: `v-aria` custom directive.

It helps you to write `aria-*` attributes better throught a Vue custom directive.

Almost the same to the `aria` prop in `<VueAria>` component, let you put all `aria-*` attributes in an object or array.

::: tip
Because the custom directive would modify the DOM element. It is different from component which renders virtual DOM. So `v-aria` will run after all `<VueAria>` executed if you put both of them on a same DOM element. And the performance of `v-aria` would be a little bit slow than `<VueAria>` if you use them quite a lot.
:::

### Examples

``` vue
<template>
  <i class="icon-save" role="button" v-aria="aria" />
</template>

<script>
export default {
  data() {
    return {
      aria: {
        label: 'save your changes',
        controls: 'id-of-a-textbox'
      }
    };
  },
  directives: {
    aria: directiveAria
  }
};
</script>
```

This example above is same to:

``` vue
<template>
  <i
    class="icon-save"
    role="button"
    aria-label="save your changes"
    aria-controls="id-of-a-textbox"
  >
</template>
```

Btw. there is not custom directives such as `v-role` and `v-tabindex` because you could set the two raw attributes directly on a component or an element with `v-aria`.

## `KeyTravel` Mixin

This mixin help you travel through focusable items by _arrow_ keys in a Vue component. At the same time you could easily fire an action by _enter_ key or _space_ key.

### Examples

#### Auto-focus

The first example is about auto-focus. Make sure where is a value (through a prop/data/computed etc.) named `autofocus` in the component. When it's truthy, the item returned by `getAutofocusItem()` would be focused when component mounted to the DOM.

``` vue
<template>
  <div>
    <button ref="btn">Click!</button>
  </div>
</template>

<script>
export default {
  mixins: [MixinKeyTravel],
  data() {
    return {
      // You can also define this value through `prop` or `computed` etc.
      autofocus: true
    }
  },
  methods: {
    // The mixin will call this method to find the focus when mounted to the DOM.
    getAutofocusItem() {
      return this.$refs.btn;
    }
  }
};
</script>
```

#### Focus Travel Using Arrow Keys

The second example is about focus travel using arrow keys in a Vue component. There are 2 files:

- `App.vue`:

  ``` vue
  <template>
    <div role="list" @keydown="keyTravel">
      <ListItem
        ref="items"
        v-for="option in options"
        :key="option.value"
        :text="option.text"
        :value="option.value"
      />
    </div>
  </template>

  <script>
  export default {
    mixins: [MixinKeyTravel],
    components: { ListItem },
    data() {
      return {
        autofocus: true,
        // Only ArrowUp and ArrowDown keys would work.
        orientation: 'vertical'
      };
    },
    props: {
      options: Array
    },
    methods: {
      // You need to define all focusable items here. And if you don't define
      // getAutofocusItem(), the first one you defined will be auto-focused.
      getKeyItems() {
        return this.$refs.items;
      }
    }
  };
  </script>
  ```

- `ListItem.vue`:

  ``` vue
  <template>
    <div role="listitem" tabindex="-1" @click="fireAction">{{ text }}</div>
  </template>

  <script>
  export default {
    props: {
      text: String,
      value: String
    },
    methods: {
      fireAction() {
        alert(this.value);
      }
    }
  };
  </script>
  ```

Here are some points you would notice:

1. Bind `@keydown="keyTravel"` to the root DOM element of your component.
2. Put a prop/data/computed named `orientation` to define which arrow keys would work.
3. Define a `getKeyItems()` method to return all focusable items.
4. Define a `fireAction()` method in `<ListItem>` for the action when user press enter or space.

Now you can use ArrowUp and ArrowDown keys to travel each items. When you press enter or space key, an alert with the value of the current focused item would be poped up.

### API

#### Method you can call

* `keyTravel(event: KeyboardEvent, config?: KeyConfig): void`

  The second parameter is optional. The key is the `key` in the keyboard event, and the value if the "travel signal" to trigger when user press the corresponding key.

  All available travel signals: `prev`, `next`, `prevPage`, `nextPage`, `first`, `last`, `action`.

  Default config:

  * `ArrowUp`: `prev` when `this.orientation` is `vertical` or empty
  * `ArrowDown`: `next` when `this.orientation` is `vertical` or empty
  * `ArrowLeft`: `prev` when `this.orientation` is `horizontal` or empty
  * `ArrowRight`: `next` when `this.orientation` is `horizontal` or empty
  * `Home`: `first`
  * `End`: `last`
  * `Enter`: `action`
  * `Space`: `action`


#### Values you can define

* `autofocus: boolean`
* `orientation: 'horizontal' | 'vertical' | other`

#### Methods you can override

_Main method for travel:_

* `getKeyItems(): Array<Vue | HTMLElement>`: return an empty array by default

_Main method for auto-focus:_

* `getAutofocusItem(): void`: return first key item by default

_Methods you can customize to fire action:_

* `fireAction(item: Vue | HTMLElement): void`: call `item.fireAction()` by default

_Methods you can customize to travel:_

* `goPrev(): void`: focus previous item
* `goNext(): void`: focus next item
* `goFirst(): void`: focus the first item
* `goLast(): void`: focus the last item
* `goNextPage(): void`: do nothing by default
* `goPrevPage(): void`: do nothing by default
* `goAction(): void`: fire action at the current focused item

#### Method you can define in item component

* `fireAction(): void`

## `Id` Mixin

In modern web framework today, the id attribute of an element is almost never used. But in WAI-ARIA, some `aria-*` attributes like `aria-controls`, `aria-labelledby` only accept _id reference_ or _id reference list_. Another problem about id is that it's always global unique. But every Vue component has its own scope. It's not easy to make sure the id in this component wouldn't be used in other Vue components.

This mixin help you generate unique id (sometimes as an id prefix) for elements in a component by default. And you can also easily specify the id manually if necessary.

### Examples

#### Generate unique id

`input.vue`:

``` vue
<template>
  <div :id="localId">
    <label ref="label" :id="`${localId}-label`">Username</label>
    <input
      ref="input"
      :id="`${localId}-input`"
      :aria-labelledby="`${localId}-label`"
    />
  </div>
</template>

<script>
export default {
  mixins: [MixinId]
};
</script>
```

In this example, the `localId` is a data member which is generated by `Id` mixin. It's globally unique so you don't need worry about that.

If you have a form with a group of inputs, this example above will be suitable.

#### Use id passed from parent component

Think about you should bind a clear button out of the input component above. For this kind of cases, you can easily set an `id` prop to it from parent like this:

`foo.vue`:

``` vue
<template>
  <div>
    <VueInput id="foo" />
    <button aria-controls="foo-input">Clear</button>
  </div>
</template>

<script>
import VueInput from 'input.vue';
export default {
  mixins: [MixinId],
  components: { VueInput }
};
</script>
```

Now the final generated DOM tree is:

``` html
<div>
  <div id="foo">
    <label id="foo-label">Username</label>
    <input id="foo-input" aria-labelledby="foo-label" />
  </div>
  <button aria-controls="foo-input">Clear</button>
</div>
```

### API

#### Props you can use

* `id: string`

#### Values you can get

* `localId: string`

## `<VueFocusTrap>` Component

Usually, when there is a modal dialog in your Vue app, you should keep the focus still in this dialog whatever you navigate with touch, mouse or keyboard.

`<VueFocusTrap>` gives you a easy way to trap focus by just two events `gofirst` and `golast` which should bind handlers to reset the focus to the first or last focusable target in the dialog.

### Examples

In this example below, after you open the modal dialog by click the trigger button, the focus will always in the 4 control elements in `<form>`, whatever you press <kbd>tab</kbd>, <kbd>tab</kbd> + <kbd>shift</kbd> or click somewhere out of the dialog:

``` vue
<template>
  <div>
    <button ref="trigger" @click="shown = true">
      Open a Modal Dialog
    </button>
    <form class="dialog" v-show="shown">
      <VueFocusTrap @gofirst="goFirst" @golast="goLast">
        <label>Email: <input ref="email" type="email" /></label>
        <label>Password: <input ref="password" type="password" /></label>
        <button ref="login" @click="shown = false">Login</button>
        <button ref="cancel">Cancel</button>
      </VueFocusTrap>
    </form>
  </div>
</template>

<script>
export default {
  components: { VueFocusTrap },
  data() { return { shown: false }; },
  watch: {
    shown(value) {
      if (value) { this.$nextTick(() => this.goFirst()); }
      else { this.$nextTick(() => this.goTrigger()); }
    }
  },
  methods: {
    goFirst() { this.$refs.email.focus(); },
    goLast() { this.$refs.cancel.focus(); },
    goTrigger() { this.$refs.trigger.focus(); }
  }
};
</script>
```

::: tip
Additionally, as a best practise of managing focus, you'd better auto-focus the first control element in when the dialog shows up, and auto-focus the trigger button back when the dialog closed. Just like the code logic in the example above.
:::

### API

#### Slots

* default slot: the content you would trap focus in.

#### Events

* `gofirst`: when you should manually set focus to the first focusable element
* `golast`: when you should manually set focus to the last focusable element

### Using `<VueFocusTrap>` Component and `KeyTravel` Mixin Together

The better thing is: you can combine `<VueFocusTrap>` component and `KeyTravel` mixin together in a widget like actionsheet.

``` vue
<template>
  <div>
    <button ref="trigger" @click="shown = true">
      Open a Modal Dialog
    </button>
    <ul class="actionsheet" v-show="shown" @keydown="keyTravel">
      <VueFocusTrap @gofirst="goFirst" @golast="goLast">
        <li
          v-for="option in options"
          :key="option.value"
          ref="items"
          tabindex="0"
        >{{ option.text }}</li>
      </VueFocusTrap>
    </ul>
  </div>
</template>

<script>
export default {
  mixins: [MixinKeyTravel],
  components: { VueFocusTrap },
  props: { options: Array, value: String },
  data() { return { shown: false, orientation: 'vertical' }; },
  watch: {
    shown(value) {
      if (value) {
        this.$nextTick(() => this.getAutofocusItem().focus());
      } else {
        this.$nextTick(() => this.goTrigger());
      }
    }
  },
  methods: {
    getKeyItems() { return this.$refs.items; },
    getAutofocusItem() {
      const items = this.getKeyItems();
      const index = this.options.map(option => option.value).indexOf(value);
      return items[index] || items[0];
    },
    goTrigger() { this.$refs.trigger.focus(); },
    fireAction(item) {
      const items = this.getKeyItems();
      const index = this.options.map(option => option.value).indexOf(value);
      const currentIndex = items.indexOf(item);
      if (index !== currentIndex) {
        const option = this.options[index];
        if (option) {
          this.$emit('input', .value);
        }
      }
      this.shown = false;
    }
  }
};
</script>
```

## `KeyShortcuts` Mixin

### Examples

Listen <kbd>CMD</kbd> + <kbd>G</kbd>:

``` vue
<template>...</template>

<script>
export default {
  mixins: [MixinKeyShortcuts],
  shortcuts: [
    {
      key: 'G', modifiers: { meta: true },
      handle(event) { alert('trigger: CMD + G'); }
    }
  ]
};
</script>
```

Another way to config <kbd>CMD</kbd> + <kbd>G</kbd> as a `keys` sequence:


``` vue
<template>...</template>

<script>
export default {
  mixins: [MixinKeyShortcuts],
  shortcuts: [
    {
      keys: [key: 'G', modifiers: { meta: true }],
      handle(event) { alert('trigger: CMD + G'); }
    }
  ]
};
</script>
```

You can also quickly config each key in `keys` as a string if there is no modifiers to declare:

``` vue
<template>...</template>

<script>
export default {
  mixins: [MixinKeyShortcuts],
  shortcuts: [
    {
      keys: ['a', 's', 'd', 'f'],
      handle(event) { alert('trigger: A-S-D-F'); }
    }
  ]
};
</script>
```

### API

#### New option you can define

* `shortcuts: Array<ShortcutConfig>`

  The interface `ShortcutConfig` is like:

  ``` ts
  {
    key: string,
    modifiers: {
      ctrl?: boolean,
      shift?: boolean,
      alt?: boolean,
      meta?: boolean
    },
    handle(event: KeyboardEvent)
  } |
  {
    keys[
      {
        key: string,
        modifiers: {
          ctrl?: boolean,
          shift?: boolean,
          alt?: boolean,
          meta?: boolean
        }
      } |
      key: string
    ],
    handle(event: KeyboardEvent)
  }
  ```
